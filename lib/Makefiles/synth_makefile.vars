##################################################################
# Variables
#
# This makefile sets the various variables that are used by the
# rules makefile
#
SHELL = /bin/sh
TOP ?= nf2_top

DESIGN_DIR ?= ..

SRC_DIR = $(DESIGN_DIR)/src
LIB_DIR = $(NF_ROOT)/lib/verilog
COMMON_DIR = $(LIB_DIR)/core/common/src
INC_DIR = $(DESIGN_DIR)/include
SYNTH_DIR = $(DESIGN_DIR)/synth
COREGEN_SRC_DIR = $(SRC_DIR)/src_coregen
COREGEN_WORK_DIR = coregen
GENERIC_TOP = $(LIB_DIR)/core/nf2/generic_top
CPCI_PROJ = cpci
CPCI_DIR = $(NF_ROOT)/projects/$(CPCI_PROJ)
CPCI_INC_DIR = $(CPCI_DIR)/include
CPCI_XML_FILE = $(CPCI_INC_DIR)/project.xml

PROJECT = $(notdir $(patsubst %/,%,$(realpath $(DESIGN_DIR))))

# Verify that the XILINX environment variable is set
ifeq ($(origin XILINX), undefined)
$(error XILINX environment variable is undefined -- Please source the Xilinx settings file from your ISE installation)
endif

# extract the library modules the user wishes to use
# these are just the directory names under LIB_DIR
PROJECT_XML_FILE = $(INC_DIR)/project.xml
ifneq ($(strip $(wildcard $(PROJECT_XML_FILE))),)
	LIB_MODULES := $(shell $(NF_ROOT)/bin/nf_register_gen.pl --project $(PROJECT) --list-modules --simple-error --quiet)
ifeq ($(strip $(LIB_MODULES)),ERROR)
$(error Error extracting list of modules from project $(PROJECT))
endif
else
$(error No project XML file defined for $(PROJECT))
	LIB_MODULES :=
endif

# verify all modules exist
$(foreach module,$(LIB_MODULES),$(if $(strip $(wildcard $(LIB_DIR)/$(module))),,$(error Module $(module) in $(LIB_MODULES_FILE) does not exist. Please verify the name.)))

# user sources: all .v file in the src directory and one level under it
SRCS := $(COMMON_DIR)/NF_2.1_defines.v $(COMMON_DIR)/udp_defines.v $(CPCI_INC_DIR)/registers.v
SRCS := $(SRCS) $(filter-out $(INC_DIR)/registers.v, $(wildcard $(INC_DIR)/*.v)) $(INC_DIR)/registers.v
SRCS := $(SRCS) $(wildcard $(SRC_DIR)/*.v) $(wildcard $(SRC_DIR)/*/*.v)

# any .xco files in the synth directory will be generated
USER_CORES := $(wildcard $(SYNTH_DIR)/*.xco)

# Generate the list of srcs generated from the user cores
ALL_USER_CORE_SRCS := $(addprefix $(COREGEN_SRC_DIR)/,$(notdir $(USER_CORES:.xco=.v)))
USER_CORE_SRCS := $(call filter-out-bases,$(SRCS),$(ALL_USER_CORE_SRCS))

# Add the user core sources to the list of sources
SRCS := $(SRCS) $(USER_CORE_SRCS)

# get the library sources: if two modules have files with the same name, then the module
# specified first in the project xml file will be used.

# First get all files...
LIB_SRCS := $(foreach module,$(LIB_MODULES),$(wildcard $(strip $(LIB_DIR)/$(module)/src/*.v)))

# Second build a list using only unique files or files that come first in the list:
# for each source in the list, build a list of files with the same name, and then
# only add it to the list if it is first in this list.
LIB_SRCS := $(foreach src,$(LIB_SRCS),$(findstring $(src),$(call first_filename_match,$(src),$(LIB_SRCS))))

# Third, remove any files that are overridden by local sources
LIB_SRCS := $(call filter-out-bases,$(SRCS),$(LIB_SRCS))

# Library includes
LIB_INC_DIRS := $(strip $(foreach module,$(LIB_MODULES),$(wildcard $(strip $(LIB_DIR)/$(module)/include))))
LIB_INCS := $(strip $(foreach module,$(LIB_MODULES),$(wildcard $(strip $(LIB_DIR)/$(module)/include/*.v))))

# Get all the library ucf files 
LIB_UCF := $(foreach module,$(LIB_MODULES),$(wildcard $(strip $(LIB_DIR)/$(module)/synth/*.ucf)))

# Remove the general ucf file 
LIB_UCF := $(call filter-out-bases,$(GENERIC_TOP)/synth/$(TOP).ucf,$(LIB_UCF))

# Line for including library includes in synthesis
INC_LINE := "-vlgincdir" $(firstword $(LIB_INC_DIRS)) $(foreach inc_dir, $(wordlist 2, $(words $(LIB_INC_DIRS)), $(LIB_INC_DIRS)), "| $(inc_dir)")

# Second build a list using only unique files or files that come first in the list:
# for each source in the list, build a list of files with the same name, and then
# only add it to the list if it is first in this list.
LIB_INCS := $(foreach src,$(LIB_INCS),$(findstring $(src),$(call first_filename_match,$(src),$(LIB_INCS))))

# Merge in the lib sources to the local sources
SRCS := $(SRCS) $(LIB_INCS) $(LIB_SRCS)

# get all the cores that might need to be made
LIB_CORES := $(foreach module,$(LIB_MODULES),$(wildcard $(LIB_DIR)/$(module)/synth/*.xco))

# Remove anything corresponding to a user core
LIB_CORES := $(call filter-out-bases,$(USER_CORES),$(LIB_CORES))

# get the presynthesized library ngc/edn files
LIB_PRESYNTH_CORES := $(foreach module,$(LIB_MODULES),$(wildcard $(LIB_DIR)/$(module)/synth/*.ngc))
LIB_PRESYNTH_CORES := $(LIB_PRESYNTH_CORES) $(foreach module,$(LIB_MODULES),$(wildcard $(LIB_DIR)/$(module)/synth/*.edn))

# Generate the file names that will be generated by the cores and remove
# anything correspoinding to an existing src
LIB_CORE_SRCS := $(subst /synth/,/$(subst $(DESIGN_DIR)/,,$(COREGEN_SRC_DIR))/,$(LIB_CORES:.xco=.v))
LIB_CORE_SRCS := $(call filter-out-bases, $(SRCS), $(LIB_CORE_SRCS))

# Append the lib core srcs to the list of srcs
SRCS := $(SRCS) $(LIB_CORE_SRCS)

# name of the global report file.
REPORT = synth.txt

# Check if we can use smartguide from a previous build
ifneq ($(USE_SMARTGUIDE),0)
	ifneq ($(strip $(wildcard $(TOP)_par.ncd)),)
		SMARTGUIDE_CP = cp $(TOP)_par.ncd smartguide.ncd
		SMARTGUIDE = -smartguide smartguide.ncd
	endif
endif

# use the timing switch
ifneq ($(TIMING),0)
	timing_switch = -timing
endif

# generate the list of cores to make
IMPL_TYPE_FOUND = $(findstring Edif,$(shell cat $(core)))
IMPL_TYPE = $(shell if [ "$(IMPL_TYPE_FOUND)" = "Edif" ] ; then echo "edn" ; else echo "ngc" ; fi)

# Transform the core names from xco into ngc/edn
USER_CORES := $(foreach core,$(USER_CORES),$(core:.xco=.$(IMPL_TYPE)))
LIB_CORES := $(foreach core,$(LIB_CORES),$(core:.xco=.$(IMPL_TYPE)))
GEN_CORES := $(USER_CORES) $(LIB_CORES)

# Filter out all of the user and library cores to build from XCOs from the
# list of presynth cores
LIB_PRESYNTH_CORES := $(call filter-out-bases, $(GEN_CORES), $(LIB_PRESYNTH_CORES))

# All cores we need
ALL_CORES := $(GEN_CORES) $(LIB_PRESYNTH_CORES)
ALL_SRCS := $(SRCS)

# Construct a list of just the core names without the directories
CORE_NAMES := $(notdir $(ALL_CORES))

